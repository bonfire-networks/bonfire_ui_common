/*
This file was generated by the Surface compiler.
*/

let PreviewActivity = {
	isTruncated(element) {
		if (
			element &&
			(element.offsetHeight < element.scrollHeight ||
				element.offsetWidth < element.scrollWidth)
		) {
			console.log("element has an overflow, ie. truncated with CSS line-clamp");
			return true;
		} else {
			console.log("element is not truncated");
			return false;
		}
	},
	mounted() {
		console.log("PreviewActivity mounted");
		this.el.addEventListener("click", (e) => {
			let trigger = this.el.querySelector(".open_preview_link");
			let anchor = e.target.closest("a");
			console.log({
				hasTriggerOrSocket: (trigger || !window.liveSocket),
				anchorCondition: (!anchor || anchor.classList.contains("preview_activity_link")),
				noSelection: (!window.getSelection().toString() || window.getSelection().toString() == ""),
				notButton: !e.target.closest("button"),
				notFigure: !e.target.closest("figure"),
				notDropdown: !e.target.closest(".dropdown"),
				notActions: !e.target.closest("[data-id=activity_actions]"),
				notWidget: !e.target.closest("[data-id=labelled_widget]")
			  });
			// Check if we should handle this click as a preview operation
			if (
				(trigger || !window.liveSocket) &&
				(!anchor || anchor.classList.contains("preview_activity_link")) &&
				!e.ctrlKey &&
				!e.metaKey &&
				(!window.getSelection().toString() ||
					window.getSelection().toString() == "") &&
				!e.target.closest("button") &&
				!e.target.closest("figure") &&
				!e.target.closest(".dropdown") &&
				!e.target.closest("[data-id=activity_actions]") &&
				!e.target.closest("[data-id=labelled_widget]")
			) {
				let uri =
					this.el.dataset.href ||
					(trigger !== undefined && trigger.getAttribute("href"));

				if (window.liveSocket) {
					console.log("PreviewActivity - opening preview content");

					// Save current scroll position
					const layout = document.getElementById("root");
					let previous_scroll = layout ? layout.scrollTop : null;
					
					// Send event to trigger preview content
					this.pushEventTo(
						trigger || "#preview_content", 
						"open", 
						{
						  previous_url: document.location.href,
						  previous_scroll: previous_scroll
						}
					);
					
					// Update browser history
					if (uri) {
						history.pushState(
						  {
							previous_url: document.location.href,
							previous_scroll: previous_scroll,
						  },
						  "",
						  uri,
						);
					}

					e.preventDefault();
				} else {
					// Fallback if not connected with live socket
					if (uri) {
						console.log("PreviewActivity - falling back to direct navigation");
						window.location = uri;
						e.preventDefault();
					}
				}
			} else {
				console.log(
					"PreviewActivity - click not handled (another action has precedence)"
				);
				return;
			}
		});
	},
};


let PreviewExtra = {
	mounted() {
		console.log("PreviewExtra mounted");
		this.el.addEventListener("click", (e) => {
			console.log("PreviewExtra click - showing extra preview");
			e.preventDefault();
			this.pushEventTo("#preview_content", "show_extra", {});
		});
	},
};


let ClosePreview = {
	mounted() {
		console.log("ClosePreview mounted");
		// close button
		this.el.addEventListener("click", (e) => {
			// Send event to LiveView to handle state changes
			this.pushEventTo("#preview_content", "close", {});
			
			// Handle browser history and scroll restoration
			this.restoreUrlAndScroll();
		});
	
		// intercept browser "back" action
		window.addEventListener("popstate", (e) => {
			console.log("popstate - attempt going back via browser");
			
			// Send event to LiveView to handle state changes
			this.pushEventTo("#preview_content", "close", {});
		});
	},

	// Simple method to restore URL and scroll with setTimeout
	restoreUrlAndScroll() {
		if (!history.state) {
			console.log("No history state available");
			return;
		}
		
		const location_before_preview = history.state["previous_url"];
		const previous_scroll = history.state["previous_scroll"];
		
		console.log("Previous scroll position:", previous_scroll);
		
		// First restore the URL - this happens immediately
		if (location_before_preview) {
			console.log("Restoring URL:", location_before_preview);
			history.pushState({}, "", location_before_preview);
		}
		
		if (previous_scroll === null || previous_scroll === undefined) {
			console.log("No scroll position to restore");
			return;
		}
		
		// Use setTimeout with 200ms delay as confirmed working by user
		setTimeout(() => {
			const layout = document.getElementById("root");
			
			if (!layout) {
				console.log("Root layout element not found");
				return;
			}
			
			console.log("Attempting to restore scroll position to:", previous_scroll);
			
			// Apply scroll using direct property for immediate effect
			layout.scrollTop = previous_scroll;
			
			// Also apply with scrollTo for better browser support
			try {
				layout.scrollTo({
					top: previous_scroll,
					behavior: "auto" // Use auto instead of instant for better compatibility
				});
			} catch (e) {
				console.error("Error using scrollTo:", e);
			}
			
			// Fallback to window scroll as a backup
			window.scrollTo(0, previous_scroll);
			
			console.log("Scroll restoration complete");
		}, 200); // 200ms delay as confirmed by user to work
	}
};
  
let CloseAll = {
	mounted() {
		if (window.liveSocket) {

		let trigger = this.el.querySelector(".open_preview_link");
		// close button
		console.log("CloseAll mounted");
		
		// Tracking variables for drag detection
		let isDragging = false;
		let hasMoved = false;
		let startX = 0;
		let startY = 0;
		
		// Distance threshold for considering a move a drag (in pixels)
		const dragThreshold = 5;
		
		// Trigger close event
		const triggerClose = () => {
			console.log("CloseAll triggering close");
			// Send event to LiveView to handle state changes
			this.pushEventTo(trigger || "#preview_content", "close", {});
			
			// Reuse the scroll position restoration from ClosePreview
			if (ClosePreview.restoreUrlAndScroll) {
				ClosePreview.restoreUrlAndScroll();
			}
		};
		
		// Track mouse down for potential drag start
		this.el.addEventListener("mousedown", (e) => {
			console.log("CloseAll mousedown");
			startX = e.clientX;
			startY = e.clientY;
			hasMoved = false;
			
			// Add mousemove and mouseup listeners to document to catch events outside the element
			document.addEventListener("mousemove", handleMouseMove);
			document.addEventListener("mouseup", handleMouseUp);
		});
		
		// Track mouse movement to detect dragging
		const handleMouseMove = (e) => {
			// Calculate distance moved
			const dx = Math.abs(e.clientX - startX);
			const dy = Math.abs(e.clientY - startY);
			
			// If moved more than threshold, consider it a drag
			if (dx > dragThreshold || dy > dragThreshold) {
				console.log("CloseAll drag detected");
				hasMoved = true;
				isDragging = true;
			}
		};
		
		// Handle end of potential drag
		const handleMouseUp = (e) => {
			console.log("CloseAll mouseup");
			// Clean up event listeners
			document.removeEventListener("mousemove", handleMouseMove);
			document.removeEventListener("mouseup", handleMouseUp);
			
			// If we had a drag operation (moved significantly), trigger close
			if (isDragging || hasMoved) {
				console.log("CloseAll drag ended - triggering close");
				triggerClose();
			}
			
			// Reset drag state
			setTimeout(() => {
				isDragging = false;
				hasMoved = false;
			}, 50);
		};
		
		// Also handle normal clicks
		this.el.addEventListener("click", (e) => {
			e.preventDefault();
			
			// If this wasn't a drag operation (which is handled by mouseup),
			// trigger the close action
			if (!isDragging && !hasMoved) {
				console.log("CloseAll click processed");
				triggerClose();
			}
		});
	}
}
};

export { PreviewActivity, PreviewExtra, ClosePreview, CloseAll };
