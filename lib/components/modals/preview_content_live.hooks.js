/*
This file was generated by the Surface compiler.
*/

// Utility functions for scroll and navigation
const utils = {
  // DOM element selectors - centralized for consistency
  selectors: {
    previewContent: "#preview_content",
    previewContents: "#the_preview_contents",
    loadingMessage: "[data-id='modal-contents'] div.m-3.text-center",
    feedActivityList: '[data-id="feed_activity_list"]',
    rootElement: "#root",
    innerContent: "#inner"
  },
  
  // Animation timing constants
  timing: {
    fastTransition: "0.05s",
    standardTransition: "0.3s"
  },
  
  // Storage keys - centralized for consistency
  storageKeys: {
    previousUrl: 'bonfire_previous_url',
    previousScroll: 'bonfire_previous_scroll',
    hideFeed: 'bonfire_hide_feed',
    entryUrl: 'bonfire_preview_entry_url'  // URL when first entering preview mode
  },

  // Track active timeouts for cleanup
  activeTimeouts: new Set(),
  
  // Debounce state for preventing rapid operations
  debounceState: {
    scrollRestoration: false,
    lastScrollRestore: 0
  },
  
  // Timeout management for memory leak prevention
  createTimeout(callback, delay) {
    const timeoutId = setTimeout(() => {
      this.activeTimeouts.delete(timeoutId);
      callback();
    }, delay);
    this.activeTimeouts.add(timeoutId);
    return timeoutId;
  },
  
  clearTimeout(timeoutId) {
    if (timeoutId) {
      clearTimeout(timeoutId);
      this.activeTimeouts.delete(timeoutId);
    }
  },
  
  clearAllTimeouts() {
    this.activeTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    this.activeTimeouts.clear();
  },
  
  // Consistent preview visibility check - single source of truth
  isPreviewVisible() {
    const previewContent = document.querySelector(this.selectors.previewContent);
    return previewContent && 
           previewContent.style.display !== "none" && 
           previewContent.getAttribute("data-show") === "true";
  },
  
  // Find the best scrollable container
  getScrollContainer() {
    const root = document.getElementById(this.selectors.rootElement.substring(1));
    if (root && root.scrollHeight > root.clientHeight) {
      return root;
    }
    return document.documentElement || document.body;
  },
  
  // Save navigation data to sessionStorage for preservation
  saveNavigationData(url, scroll) {
    try {
      sessionStorage.setItem(this.storageKeys.previousUrl, url);
      sessionStorage.setItem(this.storageKeys.previousScroll, scroll);
    } catch(e) {
      console.warn("Failed to save navigation data to sessionStorage:", e);
    }
    
    return {
      previous_url: url,
      previous_scroll: scroll
    };
  },
  
  // Get navigation data from sessionStorage
  getNavigationData() {
    try {
      const url = sessionStorage.getItem(this.storageKeys.previousUrl);
      const scrollStr = sessionStorage.getItem(this.storageKeys.previousScroll);
      const scroll = parseInt(scrollStr, 10);
      
      const result = {
        previous_url: url,
        previous_scroll: isNaN(scroll) ? null : scroll
      };
      
      return result;
    } catch(e) {
      console.warn("Failed to retrieve navigation data from sessionStorage:", e);
      return { previous_url: null, previous_scroll: null };
    }
  },
  
  // Show loading state immediately when preview is requested
  showLoadingState() {
    const previewContent = document.querySelector(this.selectors.previewContent);
    if (!previewContent) {
      console.warn("Preview content element not found");
      return;
    }
    
    // Make preview content visible
    previewContent.style.display = "block";
    previewContent.setAttribute("data-show", "true");
    if (previewContent.hasAttribute("data-hide")) {
      previewContent.removeAttribute("data-hide");
    }
    
    // Show the preview container
    const contents = document.getElementById(this.selectors.previewContents.substring(1));
    if (contents) {
      contents.style.display = "block";
      if (contents.classList.contains("hidden")) {
        contents.classList.remove("hidden");
      }
    }
    
    // Ensure loading message is visible
    const loadingElement = previewContent.querySelector(this.selectors.loadingMessage);
    if (loadingElement) {
      loadingElement.style.display = "flex";
    }
    
    // Hide inner content for better visual experience 
    const innerContent = document.getElementById(this.selectors.innerContent.substring(1));
    if (innerContent) {
      innerContent.style.transition = `opacity ${this.timing.fastTransition} ease`;
      innerContent.style.opacity = "0";
      innerContent.style.pointerEvents = "none";
      innerContent.style.visibility = "hidden";
    }
  },
  
  // Apply scroll position with consistent approach (single method to avoid conflicts)
  applyScroll(layout, scrollPosition) {
    if (!layout || scrollPosition === null || scrollPosition === undefined) return false;
    
    try {
      // Apply scroll using multiple methods for maximum compatibility
      layout.scrollTop = scrollPosition;
      
      // Use scrollTo API as primary method
      if (layout.scrollTo) {
        layout.scrollTo({
          top: scrollPosition,
          behavior: "auto"
        });
      }
      
      // Also apply to window as fallback for edge cases
      window.scrollTo(0, scrollPosition);
      
      return true;
    } catch(e) {
      console.error("Error applying scroll:", e);
      return false;
    }
  },
  
  // Hide feed to prevent flash during navigation
  hideFeed() {
    try {
      sessionStorage.setItem(this.storageKeys.hideFeed, 'true');
      const feedElement = document.querySelector(this.selectors.feedActivityList);
      if (feedElement) {
        feedElement.style.transition = `opacity ${this.timing.fastTransition} ease`;
        feedElement.style.opacity = "0";
        return feedElement;
      }
    } catch(e) {
      console.warn("Failed to hide feed:", e);
    }
    return null;
  },
  
  // Show feed after scrolling applied
  showFeed(feedElement) {
    if (!feedElement) {
      feedElement = document.querySelector(this.selectors.feedActivityList);
    }
    
    if (feedElement) {
      feedElement.style.opacity = "1";
      try {
        sessionStorage.removeItem(this.storageKeys.hideFeed);
      } catch(e) {
        console.warn("Failed to remove feed hide flag:", e);
      }
    }
  }
};

// Helper for checking if a click should open a preview
function shouldHandlePreviewClick(e, trigger) {
  // Quick rules first to fail early
  if (e.ctrlKey || e.metaKey) return false;
  
  // Check for selection
  const hasSelection = window.getSelection && 
                      window.getSelection().toString && 
                      window.getSelection().toString().trim() !== "";
  if (hasSelection) return false;
  
  // Check for ignored targets
  if (e.target.closest("button") ||
      e.target.closest("form") ||
      e.target.closest("figure") ||
      e.target.closest(".dropdown") ||
      e.target.closest("[data-id=activity_actions]") ||
      e.target.closest("[data-id=labelled_widget]")) {
    return false;
  }
  
  const anchor = e.target.closest("a");
  
  // Need to have trigger or socket available
  if (!(trigger || !window.liveSocket)) return false;
  
  // Anchor check
  if (anchor && !anchor.classList.contains("preview_activity_link")) return false;
  
  return true;
}

let PreviewActivity = {
  isTruncated(element) {
    if (element && 
        (element.offsetHeight < element.scrollHeight ||
         element.offsetWidth < element.scrollWidth)) {
      return true;
    }
    return false;
  },
  
  mounted() {
    
    // Store handler reference for proper cleanup
    this.handleClick = (e) => {
      const trigger = this.el.querySelector(".open_preview_link");
      
      // Check if we should handle this click as a preview operation
      if (shouldHandlePreviewClick(e, trigger)) {
        const uri = this.el.dataset.href ||
                    (trigger !== undefined && trigger.getAttribute("href"));
        
        if (window.liveSocket) {
          // Prevent default immediately
          e.preventDefault();
          
          // Get the original scroll position first (before any changes)
          const layout = utils.getScrollContainer();
          const previous_scroll = layout ? layout.scrollTop : null;
          
          // Show modal immediately  
          utils.showLoadingState();
          
          // Then scroll to top to see the modal content
          window.scrollTo(0, 0);
          if (layout) layout.scrollTop = 0;
          
          // Update browser history
          if (uri) {
            const navState = utils.saveNavigationData(document.location.href, previous_scroll);
            
            // Save the original entry URL when first entering a preview
            try {
              // Only store entry URL if we don't already have one (first-level preview)
              if (!sessionStorage.getItem(utils.storageKeys.entryUrl)) {
                sessionStorage.setItem(utils.storageKeys.entryUrl, document.location.href);
              }
            } catch(e) {
              console.warn("Failed to save preview entry URL:", e);
            }
            
            // Add error handling for history.pushState
            try {
              history.pushState(navState, "", uri);
            } catch(e) {
              console.warn("Failed to update browser history:", e);
            }
          }
          
          // Then send event to trigger preview content
          this.pushEventTo(
            trigger || utils.selectors.previewContent, 
            "open", 
            {
              previous_url: document.location.href,
              previous_scroll: previous_scroll
            }
          );
        } else if (uri) {
          // Fallback if not connected with live socket
          window.location = uri;
          e.preventDefault();
        }
      }
    };
    
    // Add event listener
    this.el.addEventListener("click", this.handleClick);
  },
  
  destroyed() {
    // Clean up event listener
    if (this.handleClick) {
      this.el.removeEventListener("click", this.handleClick);
    }
  }
};

let PreviewExtra = {
  mounted() {
    
    // Clean up loading state when extra view is shown
    const previewContent = document.querySelector(utils.selectors.previewContent);
    if (previewContent) {
      const loadingElement = previewContent.querySelector(utils.selectors.loadingMessage);
      if (loadingElement && loadingElement.textContent && loadingElement.textContent.includes("Loading")) {
        loadingElement.style.display = "none";
      }
    }
    
    // Store handler reference for proper cleanup
    this.handleClick = (e) => {
      e.preventDefault();
      this.pushEventTo(utils.selectors.previewContent, "show_extra", {});
    };
    
    // Add event listener
    this.el.addEventListener("click", this.handleClick);
  },
  
  destroyed() {
    // Clean up event listener
    if (this.handleClick) {
      this.el.removeEventListener("click", this.handleClick);
    }
  }
};

let ClosePreview = {
  mounted() {
    
    // Store the handler references for proper cleanup
    this.handleClick = (e) => {
      // Send event to LiveView to handle state changes
      this.pushEventTo(utils.selectors.previewContent, "close", {});
      
      // Handle browser history and scroll restoration with debouncing
      this.restoreUrlAndScroll();
    };
    
    this.handlePopState = (e) => {
      
      // Send event to LiveView to handle state changes
      this.pushEventTo(utils.selectors.previewContent, "close", {});
      
      // Also restore scroll position on popstate
      this.restoreUrlAndScroll();
    };
    
    // Add event listeners
    this.el.addEventListener("click", this.handleClick);
    window.addEventListener("popstate", this.handlePopState);
  },
  
  destroyed() {
    // Clean up event listeners
    if (this.handleClick) {
      this.el.removeEventListener("click", this.handleClick);
    }
    
    if (this.handlePopState) {
      window.removeEventListener("popstate", this.handlePopState);
    }
  },

  // Enhanced method for more reliable URL and scroll restoration
  restoreUrlAndScroll() {
    console.log("ClosePreview.restoreUrlAndScroll called");
    
    // Implement debouncing to prevent rapid successive calls
    const now = Date.now();
    if (utils.debounceState.scrollRestoration && (now - utils.debounceState.lastScrollRestore) < 300) {
      console.log("Debounced - skipping restoration");
      return;
    }
    utils.debounceState.scrollRestoration = true;
    utils.debounceState.lastScrollRestore = now;
    
    // No active timeouts to clean up since we removed them
    
    // Use multiple data sources for maximum reliability
    const state = history.state || {};
    const storedData = utils.getNavigationData();
    
    console.log("Restoration data:", {
      historyState: state,
      storedData: storedData,
      entryUrl: sessionStorage.getItem(utils.storageKeys.entryUrl)
    });
    
    // Combine state and sessionStorage data, with state taking precedence
    const navData = {
      previous_url: (() => {
        try {
          // First try to get the original entry URL
          const entryUrl = sessionStorage.getItem(utils.storageKeys.entryUrl);
          if (entryUrl) {
            console.log("Using entry URL:", entryUrl);
            // Clear the entry URL after using it
            sessionStorage.removeItem(utils.storageKeys.entryUrl);
            return entryUrl;
          }
        } catch(e) {
          console.warn("Error accessing preview entry URL:", e);
        }
        // Fall back to existing chain if no entry URL
        const fallbackUrl = state.previous_url || storedData.previous_url || document.referrer || window.location.href;
        console.log("Using fallback URL:", fallbackUrl);
        return fallbackUrl;
      })(),
      previous_scroll: state.previous_scroll !== undefined ? state.previous_scroll : 
                      (storedData.previous_scroll !== undefined ? storedData.previous_scroll : 0)
    };
    
    console.log("Final navigation data:", navData);
    
    // First restore the URL - Always use replaceState for maximum reliability
    if (navData.previous_url && navData.previous_url !== window.location.href) {
      try {
        console.log("Restoring URL from", window.location.href, "to", navData.previous_url);
        history.replaceState({}, "", navData.previous_url);
      } catch(e) {
        console.warn("Failed to restore URL:", e);
      }
    }
    
    // Ensure we have a valid scroll position (default to 0 if none found)
    const scrollPosition = parseInt(navData.previous_scroll, 10);
    if (isNaN(scrollPosition)) {
      navData.previous_scroll = 0;
    } else {
      navData.previous_scroll = scrollPosition;
    }
    
    console.log("Scroll position to restore:", navData.previous_scroll);
    
    // Hide feed to prevent flash
    const feedElement = utils.hideFeed();
    
    // Restore inner content visibility immediately
    const innerContent = document.getElementById(utils.selectors.innerContent.substring(1));
    if (innerContent) {
      innerContent.style.transition = `opacity ${utils.timing.standardTransition} ease`;
      innerContent.style.opacity = "1";
      innerContent.style.pointerEvents = "auto";
      innerContent.style.visibility = "visible";
    }
    
    // Delay scroll restoration until after LiveView updates are complete
    // LiveView updates are causing scroll to reset to 0
    // TODO: Consider using LiveView's updated() callback for more robust timing
    // instead of setTimeout - would eliminate guesswork about LiveView update cycles
    setTimeout(() => {
      console.log("Delayed scroll restoration starting...");
      this.applyScrollRestore(navData.previous_scroll, feedElement);
    }, 100);
    
    // Reset debounce state immediately after operation completes
    utils.debounceState.scrollRestoration = false;
  },
  
  // Simplified scroll restoration without complex retry logic
  applyScrollRestore(position, feedElement) {
    console.log("applyScrollRestore called with position:", position);
    
    const layout = utils.getScrollContainer();
    console.log("Scroll container:", layout);
    
    if (!layout) {
      console.log("No layout container found, using window.scrollTo");
      window.scrollTo(0, position);
      utils.showFeed(feedElement);
      return;
    }
    
    try {
      // Apply scroll with utility method
      const scrollSuccess = utils.applyScroll(layout, position);
      console.log("Scroll applied successfully:", scrollSuccess);
      
      // Force scroll restoration with multiple attempts to handle LiveView interference
      if (position > 0) {
        console.log("Applying scroll with persistent methods for position:", position);
        
        // Method 1: Immediate application
        if (layout.scrollTo) {
          layout.scrollTo({ top: position, behavior: 'instant' });
        }
        layout.scrollTop = position;
        
        // Method 2: Retry after DOM updates
        const retryScroll = () => {
          layout.scrollTop = position;
          console.log("Retry scroll position set to:", position, "actual:", layout.scrollTop);
          
          // If still at 0, try again
          if (layout.scrollTop === 0 && position > 0) {
            console.log("Scroll was reset, retrying...");
            setTimeout(() => {
              layout.scrollTop = position;
              console.log("Final retry scroll position:", layout.scrollTop);
            }, 50);
          }
        };
        
        // Multiple retries with increasing delays to handle LiveView updates
        requestAnimationFrame(retryScroll);
        setTimeout(retryScroll, 50);
        setTimeout(retryScroll, 150);
      }
      
      // Show feed immediately - scroll is applied synchronously
      utils.showFeed(feedElement);
      console.log("Feed shown after scroll restoration");
      
    } catch(e) {
      console.error("Error during scroll restoration:", e);
      utils.showFeed(feedElement); // Always show feed, even if scroll fails
    }
  }
};
  
let CloseAll = {
  mounted() {
    if (!window.liveSocket) return;

    const trigger = this.el.querySelector(".open_preview_link");
    
    // Simplified close function without complex method binding
    this.triggerClose = () => {
      
      // Send event to LiveView to handle state changes
      this.pushEventTo(trigger || utils.selectors.previewContent, "close", {});
      
      // Simple scroll restoration fallback
      try {
        const storedPosition = parseInt(sessionStorage.getItem(utils.storageKeys.previousScroll), 10) || 0;
        const layout = utils.getScrollContainer();
        if (layout) {
          utils.applyScroll(layout, storedPosition);
        } else {
          window.scrollTo(0, storedPosition);
        }
        
        // Clean up entry URL
        sessionStorage.removeItem(utils.storageKeys.entryUrl);
      } catch(e) {
        console.warn("Error during simple scroll restoration:", e);
      }
    };
    
    // Simplified click handler using the centralized visibility check
    this.handleClick = (e) => {
      // Only prevent default and trigger close if preview content is actually visible
      if (utils.isPreviewVisible()) {
        e.preventDefault();
        this.triggerClose();
      }
      // Otherwise, let the link work normally
    };
    
    // Store reference to DOM event handlers for cleanup
    this.handleKeyDown = (e) => {
      // Add Escape key support for accessibility - only if preview is visible
      if (e.key === 'Escape' && utils.isPreviewVisible()) {
        this.triggerClose();
      }
    };
    
    // Add event listeners
    this.el.addEventListener("click", this.handleClick);
    document.addEventListener("keydown", this.handleKeyDown);
  },
  
  destroyed() {
    // Clean up event listeners
    if (this.handleClick) {
      this.el.removeEventListener("click", this.handleClick);
    }
    
    if (this.handleKeyDown) {
      document.removeEventListener("keydown", this.handleKeyDown);
    }
  }
};

// Simple MainFeed hook to handle feed visibility during navigation
let MainFeed = {
  mounted() {
    const shouldHide = sessionStorage.getItem(utils.storageKeys.hideFeed) === 'true';
    
    // Track timeout for cleanup
    this.showFeedTimeout = null;
    
    // Clean up any stale entry URLs when returning to feed
    try {
      sessionStorage.removeItem(utils.storageKeys.entryUrl);
    } catch(e) {
      console.warn("Failed to clean up entry URL in MainFeed:", e);
    }
    
    if (shouldHide) {
      const feedElement = document.querySelector(utils.selectors.feedActivityList);
      if (feedElement) {
        feedElement.style.opacity = "0";
        feedElement.style.transition = `opacity ${utils.timing.standardTransition} ease`;
        
        // Store the element for later
        this.hiddenFeedElement = feedElement;
        
        // Show the feed after a brief delay to allow transition to be set
        this.showFeedTimeout = setTimeout(() => {
          if (this.hiddenFeedElement) {
            this.hiddenFeedElement.style.opacity = "1";
            try {
              sessionStorage.removeItem(utils.storageKeys.hideFeed);
            } catch(e) {
              console.warn("Failed to remove hideFeed flag:", e);
            }
            this.hiddenFeedElement = null;
          }
          this.showFeedTimeout = null;
        }, 10);
      }
    }
  },
  
  destroyed() {
    // Clean up timeout first
    if (this.showFeedTimeout) {
      clearTimeout(this.showFeedTimeout);
      this.showFeedTimeout = null;
    }
    
    // Make sure feed is visible if we're being destroyed
    if (this.hiddenFeedElement) {
      this.hiddenFeedElement.style.opacity = "1";
      this.hiddenFeedElement = null;
    }
  }
};

export { PreviewActivity, PreviewExtra, ClosePreview, CloseAll, MainFeed };
