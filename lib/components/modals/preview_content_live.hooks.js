/*
This file was generated by the Surface compiler.
*/

// Utility functions for scroll and navigation
const utils = {
  // DOM element selectors - centralized for consistency
  selectors: {
    previewContent: "#preview_content",
    previewContents: "#the_preview_contents",
    loadingMessage: "[data-id='modal-contents'] div.m-3.text-center",
    feedActivityList: '[data-id="feed_activity_list"]',
    rootElement: "#root",
    innerContent: "#inner"
  },
  
  // Animation timing constants
  timing: {
    fastTransition: "0.05s",
    standardTransition: "0.3s"
  },
  
  // Storage keys - centralized for consistency
  storageKeys: {
    previousUrl: 'bonfire_previous_url',
    previousScroll: 'bonfire_previous_scroll',
    hideFeed: 'bonfire_hide_feed',
    entryUrl: 'bonfire_preview_entry_url'  // URL when first entering preview mode
  },
  
  // Find the best scrollable container
  getScrollContainer() {
    const root = document.getElementById(this.selectors.rootElement.substring(1));
    if (root && root.scrollHeight > root.clientHeight) {
      return root;
    }
    return document.documentElement || document.body;
  },
  
  // Save navigation data to sessionStorage for preservation
  saveNavigationData(url, scroll) {
    console.log("Saving navigation data - URL:", url, "Scroll position:", scroll);
    
    try {
      sessionStorage.setItem(this.storageKeys.previousUrl, url);
      sessionStorage.setItem(this.storageKeys.previousScroll, scroll);
      console.log("Navigation data saved to sessionStorage");
    } catch(e) {
      console.warn("Failed to save navigation data to sessionStorage:", e);
    }
    
    return {
      previous_url: url,
      previous_scroll: scroll
    };
  },
  
  // Get navigation data from sessionStorage
  getNavigationData() {
    console.log("Retrieving navigation data from sessionStorage");
    
    try {
      const url = sessionStorage.getItem(this.storageKeys.previousUrl);
      const scrollStr = sessionStorage.getItem(this.storageKeys.previousScroll);
      const scroll = parseInt(scrollStr, 10);
      
      const result = {
        previous_url: url,
        previous_scroll: isNaN(scroll) ? null : scroll
      };
      
      console.log("Retrieved navigation data:", result, "Raw scroll value:", scrollStr);
      return result;
    } catch(e) {
      console.warn("Failed to retrieve navigation data from sessionStorage:", e);
      return { previous_url: null, previous_scroll: null };
    }
  },
  
  // Show loading state immediately when preview is requested
  showLoadingState() {
    const previewContent = document.querySelector(this.selectors.previewContent);
    if (!previewContent) return;
    
    // Make preview content visible
    previewContent.style.display = "block";
    previewContent.setAttribute("data-show", "true");
    if (previewContent.hasAttribute("data-hide")) {
      previewContent.removeAttribute("data-hide");
    }
    
    // Show the preview container
    const contents = document.getElementById(this.selectors.previewContents.substring(1));
    if (contents) {
      contents.style.display = "block";
      if (contents.classList.contains("hidden")) {
        contents.classList.remove("hidden");
      }
    }
    
    // Ensure loading message is visible
    const loadingElement = previewContent.querySelector(this.selectors.loadingMessage);
    if (loadingElement) {
      loadingElement.style.display = "flex";
    }
    
    // Hide inner content for better visual experience 
    const innerContent = document.getElementById(this.selectors.innerContent.substring(1));
    if (innerContent) {
      innerContent.style.transition = `opacity ${this.timing.fastTransition} ease`;
      innerContent.style.opacity = "0";
      innerContent.style.pointerEvents = "none";
      innerContent.style.visibility = "hidden";
    }
  },
  
  // Apply scroll position with consistent approach
  applyScroll(layout, scrollPosition) {
    if (!layout || scrollPosition === null || scrollPosition === undefined) return false;
    
    // Apply scroll using all methods for maximum compatibility
    try {
      // Direct property assignment (most widely supported)
      layout.scrollTop = scrollPosition;
      
      // Modern scrollTo API (better for most browsers)
      try {
        layout.scrollTo({
          top: scrollPosition,
          behavior: "auto" // Instant jump to correct position
        });
      } catch(e) {
        console.warn("Modern scrollTo not supported:", e);
      }
      
      // Also apply to window as fallback
      window.scrollTo(0, scrollPosition);
      
      return true;
    } catch(e) {
      console.error("Error applying scroll:", e);
      return false;
    }
  },
  
  // Hide feed to prevent flash during navigation
  hideFeed() {
    try {
      sessionStorage.setItem(this.storageKeys.hideFeed, 'true');
      const feedElement = document.querySelector(this.selectors.feedActivityList);
      if (feedElement) {
        feedElement.style.transition = `opacity ${this.timing.fastTransition} ease`;
        feedElement.style.opacity = "0";
        return feedElement;
      }
    } catch(e) {
      console.warn("Failed to hide feed:", e);
    }
    return null;
  },
  
  // Show feed after scrolling applied
  showFeed(feedElement) {
    if (!feedElement) {
      feedElement = document.querySelector(this.selectors.feedActivityList);
    }
    
    if (feedElement) {
      feedElement.style.opacity = "1";
      try {
        sessionStorage.removeItem(this.storageKeys.hideFeed);
      } catch(e) {
        console.warn("Failed to remove feed hide flag:", e);
      }
    }
  }
};

// Helper for checking if a click should open a preview
function shouldHandlePreviewClick(e, trigger) {
  // Quick rules first to fail early
  if (e.ctrlKey || e.metaKey) return false;
  
  // Check for selection
  const hasSelection = window.getSelection && 
                      window.getSelection().toString && 
                      window.getSelection().toString().trim() !== "";
  if (hasSelection) return false;
  
  // Check for ignored targets
  if (e.target.closest("button") ||
      e.target.closest("figure") ||
      e.target.closest(".dropdown") ||
      e.target.closest("[data-id=activity_actions]") ||
      e.target.closest("[data-id=labelled_widget]")) {
    return false;
  }
  
  const anchor = e.target.closest("a");
  
  // Need to have trigger or socket available
  if (!(trigger || !window.liveSocket)) return false;
  
  // Anchor check
  if (anchor && !anchor.classList.contains("preview_activity_link")) return false;
  
  return true;
}

let PreviewActivity = {
  isTruncated(element) {
    if (element && 
        (element.offsetHeight < element.scrollHeight ||
         element.offsetWidth < element.scrollWidth)) {
      return true;
    }
    return false;
  },
  
  mounted() {
    console.log("PreviewActivity mounted");
    
    // Store handler reference for proper cleanup
    this.handleClick = (e) => {
      const trigger = this.el.querySelector(".open_preview_link");
      
      // Check if we should handle this click as a preview operation
      if (shouldHandlePreviewClick(e, trigger)) {
        const uri = this.el.dataset.href ||
                    (trigger !== undefined && trigger.getAttribute("href"));
        
        if (window.liveSocket) {
          // Prevent default immediately
          e.preventDefault();
          
          // Get the original scroll position first (before any changes)
          const layout = utils.getScrollContainer();
          const previous_scroll = layout ? layout.scrollTop : null;
          
          console.log("Captured scroll position before preview:", previous_scroll, "from container:", layout.id || 'document.body/documentElement');
          
          // Show modal immediately  
          utils.showLoadingState();
          
          // Then scroll to top to see the modal content
          window.scrollTo(0, 0);
          if (layout) layout.scrollTop = 0;
          
          // Update browser history
          if (uri) {
            const navState = utils.saveNavigationData(document.location.href, previous_scroll);
            
            // Save the original entry URL when first entering a preview
            try {
              // Only store entry URL if we don't already have one (first-level preview)
              if (!sessionStorage.getItem(utils.storageKeys.entryUrl)) {
                sessionStorage.setItem(utils.storageKeys.entryUrl, document.location.href);
                console.log("Preview entry URL saved:", document.location.href);
              }
            } catch(e) {
              console.warn("Failed to save preview entry URL:", e);
            }
            
            history.pushState(navState, "", uri);
            console.log("History state updated with scroll position:", previous_scroll);
          }
          
          // Then send event to trigger preview content
          this.pushEventTo(
            trigger || utils.selectors.previewContent, 
            "open", 
            {
              previous_url: document.location.href,
              previous_scroll: previous_scroll
            }
          );
        } else if (uri) {
          // Fallback if not connected with live socket
          window.location = uri;
          e.preventDefault();
        }
      }
    };
    
    // Add event listener
    this.el.addEventListener("click", this.handleClick);
  },
  
  destroyed() {
    // Clean up event listener
    if (this.handleClick) {
      this.el.removeEventListener("click", this.handleClick);
    }
  }
};

let PreviewExtra = {
  mounted() {
    console.log("PreviewExtra mounted");
    
    // Clean up loading state when extra view is shown
    const previewContent = document.querySelector(utils.selectors.previewContent);
    if (previewContent) {
      const loadingElement = previewContent.querySelector(utils.selectors.loadingMessage);
      if (loadingElement && loadingElement.textContent.includes("Loading")) {
        loadingElement.style.display = "none";
      }
    }
    
    // Store handler reference for proper cleanup
    this.handleClick = (e) => {
      e.preventDefault();
      this.pushEventTo(utils.selectors.previewContent, "show_extra", {});
    };
    
    // Add event listener
    this.el.addEventListener("click", this.handleClick);
  },
  
  destroyed() {
    // Clean up event listener
    if (this.handleClick) {
      this.el.removeEventListener("click", this.handleClick);
    }
  }
};

let ClosePreview = {
  mounted() {
    console.log("ClosePreview mounted");
    
    // Store the handler references for proper cleanup
    this.handleClick = (e) => {
      // Send event to LiveView to handle state changes
      this.pushEventTo(utils.selectors.previewContent, "close", {});
      
      // Handle browser history and scroll restoration
      this.restoreUrlAndScroll();
    };
    
    this.handlePopState = (e) => {
      console.log("popstate - attempt going back via browser");
      
      // Send event to LiveView to handle state changes
      this.pushEventTo(utils.selectors.previewContent, "close", {});
      
      // Also restore scroll position on popstate
      this.restoreUrlAndScroll();
    };
    
    // Add event listeners
    this.el.addEventListener("click", this.handleClick);
    window.addEventListener("popstate", this.handlePopState);
  },
  
  destroyed() {
    // Clean up event listeners
    if (this.handleClick) {
      this.el.removeEventListener("click", this.handleClick);
    }
    
    if (this.handlePopState) {
      window.removeEventListener("popstate", this.handlePopState);
    }
  },

  // Enhanced method for more reliable URL and scroll restoration
  restoreUrlAndScroll() {
    console.log("Attempting to restore URL and scroll position");
    
    // Use multiple data sources for maximum reliability
    const state = history.state || {};
    const storedData = utils.getNavigationData();
    
    // Combine state and sessionStorage data, with state taking precedence
    const navData = {
      previous_url: (() => {
        try {
          // First try to get the original entry URL
          const entryUrl = sessionStorage.getItem(utils.storageKeys.entryUrl);
          if (entryUrl) {
            console.log("Using preview entry URL for restoration:", entryUrl);
            // Clear the entry URL after using it
            sessionStorage.removeItem(utils.storageKeys.entryUrl);
            return entryUrl;
          }
        } catch(e) {
          console.warn("Error accessing preview entry URL:", e);
        }
        // Fall back to existing chain if no entry URL
        return state.previous_url || storedData.previous_url || document.referrer || window.location.href;
      })(),
      previous_scroll: state.previous_scroll !== undefined ? state.previous_scroll : 
                      (storedData.previous_scroll !== undefined ? storedData.previous_scroll : 0)
    };
    
    console.log("Combined navigation data:", navData);
    
    // First restore the URL - Always use replaceState for maximum reliability
    if (navData.previous_url && navData.previous_url !== window.location.href) {
      try {
        // replaceState is more reliable than pushState for all cases
        history.replaceState({}, "", navData.previous_url);
        console.log("URL restored to:", navData.previous_url);
      } catch(e) {
        console.warn("Failed to restore URL:", e);
      }
    }
    
    // Ensure we have a valid scroll position (default to 0 if none found)
    const scrollPosition = parseInt(navData.previous_scroll, 10);
    if (isNaN(scrollPosition)) {
      console.log("Invalid scroll position, defaulting to 0");
      navData.previous_scroll = 0;
    } else {
      navData.previous_scroll = scrollPosition;
    }
    
    console.log("Target scroll position:", navData.previous_scroll);
    
    // Hide feed to prevent flash
    const feedElement = utils.hideFeed();
    
    // Multiple scroll attempts with increasing delays for reliability
    this.applyScrollWithRetries(navData.previous_scroll, feedElement);
    
    // Restore inner content visibility
    const innerContent = document.getElementById(utils.selectors.innerContent.substring(1));
    if (innerContent) {
      innerContent.style.transition = `opacity ${utils.timing.standardTransition} ease`;
      innerContent.style.opacity = "1";
      innerContent.style.pointerEvents = "auto";
      innerContent.style.visibility = "visible";
    }
  },
  
  // Improved method to apply scroll with fewer retries and better approach
  applyScrollWithRetries(position, feedElement, attempt = 1) {
    const maxAttempts = 3; // Reduced from 5 to 3 for efficiency
    const layout = utils.getScrollContainer();
    
    if (!layout) {
      console.log("No scroll container found, trying window only");
      window.scrollTo(0, position);
      utils.showFeed(feedElement);
      return;
    }
    
    console.log(`Scroll attempt ${attempt}/${maxAttempts}, target: ${position}`);
    
    try {
      // Try applying scroll with our utility method
      const scrollSuccess = utils.applyScroll(layout, position);
      
      // Verify if scroll was successful
      const currentScroll = layout.scrollTop;
      const scrollDiff = Math.abs(currentScroll - position);
      
      console.log(`Scroll applied, current position: ${currentScroll}, diff: ${scrollDiff}`);
      
      // If we're far from the target position and have more attempts, try again with increasing delay
      if (scrollDiff > 50 && attempt < maxAttempts) {
        const delay = attempt * 100; // Increased delay (100ms, 200ms, 300ms)
        console.log(`Scroll difference too large, retrying in ${delay}ms`);
        setTimeout(() => {
          this.applyScrollWithRetries(position, feedElement, attempt + 1);
        }, delay);
        return;
      }
      
      // Show feed after final scroll attempt
      setTimeout(() => {
        utils.showFeed(feedElement);
        console.log("Scroll restoration complete, feed shown");
      }, 50);
      
    } catch(e) {
      console.error("Error during scroll restoration:", e);
      utils.showFeed(feedElement); // Always show feed, even if scroll fails
    }
  }
};
  
let CloseAll = {
  mounted() {
    if (!window.liveSocket) return;

    const trigger = this.el.querySelector(".open_preview_link");
    console.log("CloseAll mounted");
    
    // Trigger close event - reusable function
    this.triggerClose = () => {
      console.log("CloseAll triggering close");
      
      // Send event to LiveView to handle state changes
      this.pushEventTo(trigger || utils.selectors.previewContent, "close", {});
      
      // Use proper context binding with ClosePreview
      if (ClosePreview.restoreUrlAndScroll) {
        try {
          // Create properly bound functions for both methods to maintain context
          const boundRestore = ClosePreview.restoreUrlAndScroll.bind(ClosePreview);
          const boundScrollRetries = ClosePreview.applyScrollWithRetries.bind(ClosePreview);
          
          // Temporarily add the bound function to this instance to maintain call chain
          this.applyScrollWithRetries = boundScrollRetries;
          
          // Call with proper this context
          boundRestore.call(ClosePreview);
          
          // Clean up temporary function
          delete this.applyScrollWithRetries;
        } catch(e) {
          console.error("Error during scroll restoration:", e);
          // Fallback to simpler method if the improved one fails
          const storedPosition = parseInt(sessionStorage.getItem(utils.storageKeys.previousScroll), 10) || 0;
          window.scrollTo(0, storedPosition);
        }
      }
      
      // Clean up entry URL in case it wasn't used by restoreUrlAndScroll
      try {
        sessionStorage.removeItem(utils.storageKeys.entryUrl);
      } catch(e) {
        console.warn("Failed to clean up entry URL:", e);
      }
    };
    
    // Simplified click handler
    this.handleClick = (e) => {
      // Only prevent default and trigger close if preview content is actually visible
      const previewContent = document.querySelector(utils.selectors.previewContent);
      if (previewContent && previewContent.style.display !== "none" && previewContent.getAttribute("data-show") === "true") {
        e.preventDefault();
        this.triggerClose();
      }
      // Otherwise, let the link work normally
    };
    
    // Store reference to DOM event handlers for cleanup
    this.handleKeyDown = (e) => {
      // Add Escape key support for accessibility
      if (e.key === 'Escape') {
        this.triggerClose();
      }
    };
    
    // Add event listeners
    this.el.addEventListener("click", this.handleClick);
    document.addEventListener("keydown", this.handleKeyDown);
  },
  
  destroyed() {
    // Clean up event listeners
    if (this.handleClick) {
      this.el.removeEventListener("click", this.handleClick);
    }
    
    if (this.handleKeyDown) {
      document.removeEventListener("keydown", this.handleKeyDown);
    }
  }
};

// Simple MainFeed hook to handle feed visibility during navigation
let MainFeed = {
  mounted() {
    const shouldHide = sessionStorage.getItem(utils.storageKeys.hideFeed) === 'true';
    
    // Clean up any stale entry URLs when returning to feed
    try {
      sessionStorage.removeItem(utils.storageKeys.entryUrl);
    } catch(e) {
      console.warn("Failed to clean up entry URL in MainFeed:", e);
    }
    
    if (shouldHide) {
      const feedElement = document.querySelector(utils.selectors.feedActivityList);
      if (feedElement) {
        feedElement.style.opacity = "0";
        feedElement.style.transition = `opacity ${utils.timing.standardTransition} ease`;
        
        // Store the element for later
        this.hiddenFeedElement = feedElement;
        
        // Show the feed after a short delay
        setTimeout(() => {
          if (this.hiddenFeedElement) {
            this.hiddenFeedElement.style.opacity = "1";
            sessionStorage.removeItem(utils.storageKeys.hideFeed);
            this.hiddenFeedElement = null;
          }
        }, 50);
      }
    }
  },
  
  destroyed() {
    // Make sure feed is visible if we're being destroyed
    if (this.hiddenFeedElement) {
      this.hiddenFeedElement.style.opacity = "1";
      this.hiddenFeedElement = null;
    }
  }
};

export { PreviewActivity, PreviewExtra, ClosePreview, CloseAll, MainFeed };
