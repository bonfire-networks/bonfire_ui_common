{#if @widget[:sub_widgets] && @widget[:sub_widgets] != []}
  <div
    class="py-2"
    data-sortable-item={if @parent_id && (@widget[:page] || @widget[:module]), do: true}
    data-sortable-handler
    data-order={@order}
    data-item={@widget[:page] || @widget[:module] || "default"}
  >
    <!-- <li> -->
    <details class="widget_accordion" open>
      <summary class="">
        <div class="font-bold uppercase text-xs text-base-content/50">{@widget[:text] || @widget[:name]}</div>
      </summary>
      <ul
        id={deterministic_dom_id(__MODULE__, @order, "sub_widgets", @parent_id)}
        phx-hook={if @parent_id, do: "Draggable"}
        data-widget-draggable
        data-parent={@widget[:page] || @widget[:module]}
        data-event="Bonfire.Common.Settings:reorder_sub_widget"
        class="menu relative p-0 w-full"
      >
        {#case ed(
            Bonfire.Common.Settings.get(
              [:ui, :sub_widget_order],
              [],
              current_user: current_user(@__context__)
            ),
            Types.maybe_to_atom(@widget[:page] || @widget[:module]),
            []
          )}
          {#match order_settings}
            {#for {sub_widget, index} <-
                Enum.sort_by(
                  Enum.with_index(List.wrap(@widget[:sub_widgets])),
                  fn {sub_widget, index} ->
                    ((sub_widget[:page] || sub_widget[:module]) &&
                       order_settings[
                         Types.maybe_to_atom(sub_widget[:page] || sub_widget[:module] || "default")
                       ]) || index
                  end
                )}
              <StatelessComponent
                module={Bonfire.UI.Common.WidgetLive}
                widget={sub_widget}
                is_subwidget
                to={sub_widget[:href]}
                showing_within={@showing_within}
                page={@page}
                parent_item={@widget[:page] || @widget[:module]}
                parent_id={deterministic_dom_id(__MODULE__, "#{@order}_#{index}", "sub_widget", @parent_id)}
                selected_tab={@selected_tab}
                without_label={@without_label}
                wrapper_class={@wrapper_class}
                link_class={@link_class}
                text_class={@text_class}
                icon_class={@icon_class}
                skip_badges={@skip_badges}
                order={index}
              />
            {/for}
        {/case}
      </ul>
    </details>
    <!-- </li> -->
  </div>
{#else}
  <li
    class={[
      @widget[:wrapper_class] || @wrapper_class,
      group:
        not is_nil(@widget[:page]) and (@page == @widget[:page] or @selected_tab == @widget[:page])
    ]}
    data-showing-within={@showing_within}
    data-type={"widgets_#{@parent_id}_#{@parent_item || "default"}"}
    data-sortable-item={if @parent_id && (@widget[:page] || @widget[:module]), do: true}
    data-sortable-handler
    data-order={@order}
    data-item={@widget[:page] || @widget[:module] || "default"}
  >
    {#if is_list(@widget[:sub_widgets]) and @widget[:sub_widgets] != []}
      {@widget[:text] || @widget[:name]}
    {#else}
      {#case @widget[:type]}
        {#match :link}
          <Bonfire.UI.Common.LinkWidgetLive
            widget={@widget}
            to={@widget[:href]}
            showing_within={@showing_within}
            page={@page}
            parent_id={deterministic_dom_id(__MODULE__, @order, "link_widget", @parent_id)}
            selected_tab={@selected_tab}
            without_icon={@without_icon}
            without_label={@without_label}
            wrapper_class={@wrapper_class}
            link_class={@link_class}
            text_class={@text_class}
            icon_class={@icon_class}
            skip_badges={@skip_badges}
            order={@order}
          />
        {#match Surface.Component}
          {!-- Only show wrapper title/description for custom components (declare_settings_component)
               that don't render their own labels. Built-in types (declare_settings) have @widget[:data]
               populated and render their own name/description internally. --}
          <div
            :if={!@widget[:data] && (@with_title or @with_description)}
            class="flex flex-col gap-0.5 mb-3"
          >
            <div :if={@with_title} class="text-sm font-medium text-base-content/90">{@widget[:text] || @widget[:name]}</div>
            <div :if={@with_description && @widget[:description]} class="text-sm text-base-content/50">{@widget[:description]}</div>
          </div>
          {#if @widget[:form_change] || @widget[:form_submit]}
            <form phx-change={@widget[:form_change]} phx-submit={@widget[:form_submit]}>
              <StatelessComponent
                module={@widget[:module]}
                showing_within={@showing_within}
                page={@page}
                selected_tab={@selected_tab}
                name={@widget[:text] || @widget[:name]}
                {...@data}
              />
            </form>
          {#else}
            <StatelessComponent
              module={@widget[:module]}
              showing_within={@showing_within}
              page={@page}
              selected_tab={@selected_tab}
              name={@widget[:text] || @widget[:name]}
              {...@data}
            />
          {/if}
        {#match Surface.LiveComponent}
          <div
            :if={!@widget[:data] && (@with_title or @with_description)}
            class="flex flex-col gap-0.5 mb-3"
          >
            <div :if={@with_title} class="text-sm font-medium text-base-content/90">{@widget[:text] || @widget[:name]}</div>
            <div :if={@with_description && @widget[:description]} class="text-sm text-base-content/50">{@widget[:description]}</div>
          </div>
          <StatefulComponent
            module={@widget[:module]}
            id={deterministic_dom_id(__MODULE__, @order, @widget[:page] || @widget[:module], @parent_id)}
            page={@page}
            selected_tab={@selected_tab}
            showing_within={@showing_within}
            compact={@compact}
            {...@data}
          />
        {#match nil}
        {#match :disabled}
          {raw("<!-- skipped disabled widget: #{@widget[:name]} -->")}
        {#match other}
          {error(other) && "<!-- invalid widget -->"}
      {/case}
    {/if}
  </li>
{/if}
